const { PrismaClient } = require('@prisma/client');\nconst prisma = new PrismaClient();\nconst puppeteer = require('puppeteer');\nconst { uploadBuffer } = require('../lib/gcs');\n\nasync function renderResumeHtml(user, profile, recentApps) {\n  // Basic HTML template; replace with a real template for production\n  const experienceHtml = (profile?.experience || []).map(e => `<div><strong>${e.role}</strong> - ${e.company}</div>`).join('');\n  const recentHtml = (recentApps || []).map(a => `<div><strong>${a.job.title}</strong> (${new Date(a.createdAt).toLocaleDateString()})</div>`).join('');\n  return `\n  <html>\n    <head>\n      <meta charset=\"utf-8\" />\n      <style>\n        body { font-family: Arial, sans-serif; padding: 24px; }\n        h1 { margin-bottom: 0 }\n        .section { margin-top: 16px }\n      </style>\n    </head>\n    <body>\n      <h1>${user.name || 'Unnamed'}</h1>\n      <p>${user.email}</p>\n      <div class=\"section\">\n        <h2>Headline</h2>\n        <div>${profile?.headline || ''}</div>\n      </div>\n      <div class=\"section\">\n        <h2>Experience</h2>\n        ${experienceHtml}\n      </div>\n      <div class=\"section\">\n        <h2>Recent applications</h2>\n        ${recentHtml}\n      </div>\n    </body>\n  </html>`;\n}\n\nasync function processJob(job) {\n  console.log('Processing job', job.id);\n  try {\n    await prisma.resumeJob.update({ where: { id: job.id }, data: { status: 'PROCESSING' } });\n\n    const user = await prisma.user.findUnique({ where: { id: job.userId }, include: { profile: true } });\n    const recentApps = await prisma.application.findMany({ where: { candidateId: job.userId }, orderBy: { createdAt: 'desc' }, take: 3, include: { job: true } });\n\n    const html = await renderResumeHtml(user, user.profile, recentApps);\n\n    const browser = await puppeteer.launch({ args: ['--no-sandbox', '--disable-setuid-sandbox'] });\n    const page = await browser.newPage();\n    await page.setContent(html, { waitUntil: 'networkidle0' });\n    const pdfBuffer = await page.pdf({ format: 'A4', printBackground: true });\n    await browser.close();\n\n    const destination = `resumes/${job.userId}/${Date.now()}.pdf`;\n    await uploadBuffer(pdfBuffer, destination, 'application/pdf');\n\n    const resume = await prisma.resume.create({ data: { userId: job.userId, url: destination, template: job.template || 'default', status: 'READY' } });\n\n    await prisma.resumeJob.update({ where: { id: job.id }, data: { status: 'DONE', resumeId: resume.id, processedAt: new Date() } });\n    console.log('Job completed', job.id);\n  } catch (err) {\n    console.error('Job failed', job.id, err);\n    await prisma.resumeJob.update({ where: { id: job.id }, data: { status: 'FAILED' } });\n  }\n}\n\nasync function poll() {\n  console.log('Worker started - polling for resume jobs');\n  while (true) {\n    try {\n      const job = await prisma.resumeJob.findFirst({ where: { status: 'QUEUED' }, orderBy: { createdAt: 'asc' } });\n      if (job) {\n        await processJob(job);\n      } else {\n        await new Promise(r => setTimeout(r, 3000));\n      }\n    } catch (err) {\n      console.error('Worker error', err);\n      await new Promise(r => setTimeout(r, 5000));\n    }\n  }\n}\n\npoll().catch(err => {\n  console.error('Fatal worker error', err);\n  process.exit(1);\n});